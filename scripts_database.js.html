<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: scripts/database.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: scripts/database.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// database.js
import ShortUniqueId from 'https://esm.sh/short-unique-id';
import Dexie from '../../node-modules/dexie/dist/dexie.mjs';
import { importDB, exportDB } from '../../node-modules/dexie-export-import/dist/dexie-export-import.mjs';

export const database = {};

// TODO: None of the methods involving recipe JSONs actually validate whether
// the JSON is the correct format. This could cause some serious headaches if
// we add an invalid JSON.

// TODO: Instead of adding each recipe to this array, find a way to automate
// reading files from directory.
const recipesFromFile = [
  'assets/jsons/Ghost-Pepper-Wings.json',
  'assets/jsons/Jalapeno-Garlic-Onion-Cheeseburger.json',
  'assets/jsons/Sichuan-Style-Bird-Eye-Chili-Sauce.json',
  'assets/jsons/Southwest-Stuffed-Poblano-Pepper.json',
  'assets/jsons/Spicy-Shrimp-Pad-Thai.json',
  'assets/jsons/Bun-Bo-Hue.json',
  'assets/jsons/Spicy-Thai-Basil-Chicken-Pad-Krapow-Gai.json',
  'assets/jsons/Spicy-Touchdown-Chili.json',
  'assets/jsons/Tteokbokki-Spicy-Stir-Fried-Rice-Cakes.json',
  'assets/jsons/Jjam-Bbong-Korean-Chinese-Spicy-Noodle.json',
  'assets/jsons/Carne-Asada-Tacos.json',
  'assets/jsons/Japanese-Curry-From-Scratch.json',
  'assets/jsons/Spicy-Chicken-Sandwich.json',
  'assets/jsons/Spicy-Habanero-Salsa.json',
  'assets/jsons/Zesty-Mango-Habanero-Hot-Sauce.json',
];

let loaded = false;
const uid = new ShortUniqueId();

let db = new Dexie('MyDB');
db.version(1).stores({ recipes: 'recipe_id,recipe_name,spice_level' });

/**
 * Converts a string representation of a blob to a blob.
 * Lifted from https://gist.github.com/davoclavo/4424731
 * @param {string} dataURI A string representation of a blob
 * @returns {Blob} The converted blob
 */
function dataURItoBlob(dataURI) {
  // convert base64 to raw binary data held in a string
  const byteString = atob(dataURI.split(',')[1]);

  // separate out the mime component
  const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

  // write the bytes of the string to an ArrayBuffer
  const arrayBuffer = new ArrayBuffer(byteString.length);
  const _ia = new Uint8Array(arrayBuffer);
  for (let i = 0; i &lt; byteString.length; i += 1) {
    _ia[i] = byteString.charCodeAt(i);
  }

  const dataView = new DataView(arrayBuffer);
  const blob = new Blob([dataView], { type: mimeString });
  return blob;
}

/**
 * Saves the Dexie database into local storage.
 * This function must only be called after calling loadDB().
 * @returns {Promise} Resolves true if database successfully saved, rejects otherwise.
 */
async function saveDB() {
  return new Promise((resolve, reject) => {
    if (!loaded) {
      reject(new Error('Database not loaded yet! Call loadDB().'));
    } else {
      exportDB(db)
        .then((blob) => {
          const reader = new FileReader();
          reader.onload = (event) => {
            localStorage.setItem('database', event.target.result);
          };
          reader.readAsDataURL(blob);
          resolve(true);
        })
        .catch((error) => {
          reject(error);
        });
    }
  });
}

/**
 * Loads the Dexie database from local storage if it exists.
 * Otherwise, loads recipes from file into database.
 * @returns {Promise} Resolves true if recipes succesfully loaded, rejects otherwise.
 */
async function loadDB() {
  return new Promise((resolve, reject) => {
    db.recipes.clear().then(() => {
    // If the local storage contains database, import it
      if (localStorage.getItem('database')) {
        importDB(dataURItoBlob(localStorage.getItem('database')))
          .then((data) => {
            db = data;
            loaded = true;
            resolve(true);
          })
          .catch(() => {});
      } else { // Else, fetch recipes from file and load database
        let numImported = 0;
        recipesFromFile.forEach((recipe) => {
          fetch(recipe)
            .then((response) => response.json())
            .then((data) => {
              numImported += 1;
              db.recipes.put({
                recipe_id: data.id,
                recipe_name: data.title,
                spice_level: data.spiceRating,
                recipe_data: data,
              })
                .then(() => {
                  if (numImported === recipesFromFile.length) {
                  // After importing all of the recipes, import the challenge list
                    loadChallengesFromFile()
                      .then((challenges) => {
                        saveChallenges(challenges);
                        loaded = true;
                        saveDB()
                          .then(() => {
                            resolve(true);
                          });
                      });
                  }
                });
            })
            .catch((error) => {
              loaded = false;
              reject(error);
            });
        });
      }
    });
  });
}

/**
 * Fetches the challenge list from file.
 * @returns {Promise} Resolves with the challenge list json if successful, rejects otherwise.
 */
async function loadChallengesFromFile() {
  return new Promise((resolve, reject) => {
    fetch('assets/jsons/challenges.json')
      .then((response) => response.json())
      .then((data) => {
        resolve(data);
      })
      .catch((error) => {
        reject(error);
      });
  });
}

/**
 * Saves the challenge JSON into local storage
 * @param {JSON} challengeJSON The JSON to save
 */
function saveChallenges(challengeJSON) {
  const challengeString = JSON.stringify(challengeJSON);
  localStorage.setItem('challenges', challengeString);
}

/**
 * Adds a recipe to the database.
 * If a recipe of the same name already exists, does not add in the recipe.
 * This function must only be called after calling loadDB().
 * @param {JSON} recipeJSON The JSON of the recipe to add.
 * @returns {Promise} Resolves true if the recipe was successfully added, rejects otherwise.
 */
async function addRecipe(recipeJSON) {
  return new Promise((resolve, reject) => {
    if (!loaded) {
      reject(new Error('Database not loaded yet! Call loadDB().'));
    } else {
      const id = uid();
      recipeJSON.id = id;
      db.recipes.put({
        recipe_id: id,
        recipe_name: recipeJSON.title,
        spice_level: recipeJSON.spiceRating,
        recipe_data: recipeJSON,
      })
        .then(() => {
        // After adding recipe to database, save database
          saveDB()
            .then(() => {
              resolve(true);
            });
        });
    }
  });
}

// TODO: updateRecipe() currently trusts that the recipe updating already exists in the database.
// One way to check is by checking if the recipe name exists in the database.
// However, if the user changes the recipe name, then this check obviously fails.
// Find a way to check if the recipe exists using something other than recipe name (maybe ID?)
/**
 * Updates a recipe in the database.
 * This function must only be called after calling loadDB().
 * @param {JSON} recipeJSON The JSON of the recipe to update.
 * @returns {Promise} Resolves true if the recipe was successfully updated, rejects otherwise.
 */
async function updateRecipe(recipeJSON) {
  return new Promise((resolve, reject) => {
    if (!loaded) {
      reject(new Error('Database not loaded yet! Call loadDB().'));
    } else {
      db.recipes.put({
        recipe_id: recipeJSON.id,
        recipe_name: recipeJSON.title,
        spice_level: recipeJSON.spiceRating,
        recipe_data: recipeJSON,
      }, [recipeJSON.title])
        .then(() => {
          // After updating recipe, save database
          saveDB()
            .then(() => {
              resolve(true);
            });
        });
    }
  });
}

/**
 * Deletes a recipe from the database.
 * This function must only be called after calling loadDB();
 * @param {JSON} recipeJSON The JSON of the recipe to delete.
 * @returns {Promise} Resolves true if the recipe was successfully deleted, rejects otherwise.
 */
async function deleteRecipe(recipeJSON) {
  return new Promise((resolve, reject) => {
    if (!loaded) {
      reject(new Error('Database not loaded yet! Call loadDB().'));
    } else {
      // eslint-disable-next-line prefer-destructuring
      const id = recipeJSON.id;
      db.recipes.get(id).then((recipe) => {
        if (recipe === undefined) {
          reject(new Error('Recipe does not exist in database!'));
        }
        db.recipes.delete(id)
          .then(() => {
          // After deleting recipe, save database
            saveDB()
              .then(() => {
                resolve(true);
              });
          });
      });
    }
  });
}

/**
 * Marks a recipe as completed and updates the challenge list to reflect completion.
 * @param {JSON} recipeJSON The JSON of the recipe to complete
 * @returns {Promise} Resolves true if the recipe is successfully completed, rejects otherwise.
 */
async function completeRecipe(recipeJSON) {
  return new Promise((resolve, reject) => {
    if (!loaded) {
      reject(new Error('Database not loaded yet! Call loadDB().'));
    } else if (recipeJSON.completed) {
      reject(new Error('Recipe already completed!'));
    } else {
      const challengeJSON = JSON.parse(localStorage.getItem('challenges'));
      for (let i = 0; i &lt; recipeJSON.challenges.length; i += 1) {
        for (let j = 0; j &lt; challengeJSON.challenges.length; j += 1) {
          if (challengeJSON.challenges[j].title === recipeJSON.challenges[i]) {
            challengeJSON.challenges[j].numberCompleted += 1;
            break;
          }
        }
      }
      recipeJSON.completed = true;
      updateRecipe(recipeJSON)
        .then(() => {
          saveChallenges(challengeJSON);
          resolve(true);
        });
    }
  });
}

/**
 * Gets a list of recipes that have a given spice level.
 * @param {Number} spiceLevel The spice level query between 1 and 5 inclusive.
 * @returns {Promise} Resolves with an array of recipe JSONs that match the query spice level,
 *                    rejects if spice level out of range.
 */
async function getBySpice(spiceLevel) {
  return new Promise((resolve, reject) => {
    if (typeof spiceLevel !== 'number') {
      reject(new Error('Query was not a number!'));
    } else if (spiceLevel &lt; 1 || spiceLevel > 5) {
      reject(new Error('Spice level out of range!'));
    } else {
      const jsonArray = [];
      db.recipes.where('spice_level').equals(spiceLevel).each((recipe) => {
        jsonArray.push(recipe.recipe_data);
      })
        .then(() => {
          resolve(jsonArray);
        });
    }
  });
}

/**
 * Gets the number of recipes that match a list of given names.
 * @param {Array} recipeNames A list of recipe name queries.
 * @returns {Promise} Resolves with the number of recipes matching the given names,
 *                    rejects if it fails.
 */
async function countRecipes(recipeNames) {
  return new Promise((resolve) => {
    let numRecipes = 0;
    let namesProcessed = 0;
    if (recipeNames.length === 0) {
      resolve(0);
      return;
    }
    recipeNames.forEach((recipeName) => {
      db.recipes.where('recipe_name').equals(recipeName).count()
        .then((count) => {
          numRecipes += count;
          namesProcessed += 1;
          if (namesProcessed === recipeNames.length) {
            resolve(numRecipes);
          }
        });
    });
  });
}

/**
 * Gets a list of recipes whose title contains a given name.
 * This method is slow! Avoid calling it unless necessary.
 * @param {String} queryName The recipe name query.
 * @returns {Promise} Resolves with an array of recipe JSONs whose name contains the query,
 *                    rejects if it fails.
 */
async function getByName(query) {
  return new Promise((resolve, reject) => {
    if (typeof query !== 'string') {
      reject(new Error('Query was not a string!'));
    } else {
      let recipesPushed = 0;
      const recipeNames = [];
      let filteredNames;
      const queryLower = query.toLowerCase();
      db.recipes.orderBy('recipe_name').eachUniqueKey((name) => {
        recipeNames.push(name);
      })
        .then(() => {
          filteredNames = recipeNames.filter((name) => name.toLowerCase().includes(queryLower));
          return countRecipes(filteredNames);
        })
        .then((numRecipes) => {
          const jsonArray = [];
          if (numRecipes === 0) {
            resolve(jsonArray);
            return;
          }
          filteredNames.forEach(async (name) => {
            const collection = db.recipes.where('recipe_name').equals(name);
            collection.each((recipe) => {
              jsonArray.push(recipe.recipe_data);
              recipesPushed += 1;
            })
              .then(() => {
                if (recipesPushed === numRecipes) {
                  resolve(jsonArray);
                }
              });
          });
        });
    }
  });
}

/**
 * Returns a recipe json associated with the ID
 * @param {String} id The recipe id query.
 * @returns {Promise} Resolves with a recipe JSON whose id is the query,
 *                    rejects if it fails.
 */
async function getById(id) {
  return new Promise((resolve, reject) => {
    db.recipes.get(id)
      .then((data) => {
        resolve(data.recipe_data);
      })
      .catch((error) => {
        reject(error);
      });
  });
}

/**
 * Gets the challenge list from local storage
 * @returns {JSON} The challenge list JSON
 */
function getChallenges() {
  return JSON.parse(localStorage.getItem('challenges'));
}

database.loadDB = loadDB;
database.saveDB = saveDB;
database.addRecipe = addRecipe;
database.updateRecipe = updateRecipe;
database.deleteRecipe = deleteRecipe;
database.completeRecipe = completeRecipe;
database.getBySpice = getBySpice;
database.getByName = getByName;
database.getById = getById;
database.getChallenges = getChallenges;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ChallengeBar.html">ChallengeBar</a></li><li><a href="RecipeCard.html">RecipeCard</a></li><li><a href="RecipeDisplay.html">RecipeDisplay</a></li><li><a href="RecipeUpload.html">RecipeUpload</a></li><li><a href="Router_Router.html">Router</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addCreateRecipe">addCreateRecipe</a></li><li><a href="global.html#addRecipe">addRecipe</a></li><li><a href="global.html#bindCancelButton">bindCancelButton</a></li><li><a href="global.html#bindCreateRecipe">bindCreateRecipe</a></li><li><a href="global.html#bindDeleteButton">bindDeleteButton</a></li><li><a href="global.html#bindEditButton">bindEditButton</a></li><li><a href="global.html#bindEscKey">bindEscKey</a></li><li><a href="global.html#bindPopstate">bindPopstate</a></li><li><a href="global.html#bindProgressBar">bindProgressBar</a></li><li><a href="global.html#bindRecipeCard">bindRecipeCard</a></li><li><a href="global.html#bindSlider">bindSlider</a></li><li><a href="global.html#bindSubmitButton">bindSubmitButton</a></li><li><a href="global.html#calculateTime">calculateTime</a></li><li><a href="global.html#clickLogoToGoHome">clickLogoToGoHome</a></li><li><a href="global.html#completeRecipe">completeRecipe</a></li><li><a href="global.html#countRecipes">countRecipes</a></li><li><a href="global.html#createCheckbox">createCheckbox</a></li><li><a href="global.html#createProgressBars">createProgressBars</a></li><li><a href="global.html#createRecipeCards">createRecipeCards</a></li><li><a href="global.html#dataURItoBlob">dataURItoBlob</a></li><li><a href="global.html#deleteRecipe">deleteRecipe</a></li><li><a href="global.html#displaySearchCards">displaySearchCards</a></li><li><a href="global.html#getById">getById</a></li><li><a href="global.html#getByName">getByName</a></li><li><a href="global.html#getBySpice">getBySpice</a></li><li><a href="global.html#getChallenges">getChallenges</a></li><li><a href="global.html#getIngredient">getIngredient</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#loadChallengesFromFile">loadChallengesFromFile</a></li><li><a href="global.html#loadDB">loadDB</a></li><li><a href="global.html#saveChallenges">saveChallenges</a></li><li><a href="global.html#saveDB">saveDB</a></li><li><a href="global.html#sliderSpiceLevel">sliderSpiceLevel</a></li><li><a href="global.html#triggerSlider">triggerSlider</a></li><li><a href="global.html#updateRecipe">updateRecipe</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Thu Dec 02 2021 22:25:33 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
